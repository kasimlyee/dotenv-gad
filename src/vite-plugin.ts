/**
 * Vite-dotenv-gad
 *
 * Runs dotenv-gad validation exclusively in Node.js (inside Vite hooks),
 * then exposes the filtered, validated env through a virtual module.
 *
 * Usage:
 *      import dotenvGad from 'dotenv-gad/vite';
 *
 *      export default defineConfig({
 *          plugins: [
 *              dotenvGad({
 *                  schemaPath: './env.schema.ts',
 *                  publicKeys: ['MY_PUBLIC_KEY'],
 *              })
 *          ]
 *      })
 *
 * Inside app:
 *      import { env } from 'dotenv-gad/client';
 *      console.log(env.VITE_API_URL);
 *
 */

import { resolve, relative, dirname } from "node:path";
import { existsSync, realpathSync } from "node:fs";
import { writeFile } from "node:fs/promises";
import type { Plugin, ViteDevServer, HmrContext, ResolvedConfig } from "vite";
import type { SchemaDefinition } from "./schema.js";
import { EnvValidator } from "./validator.js";
import { loadSchema } from "./schema-loader.js";

const MODULE_ID = "virtual:dotenv-gad";
const RESOLVED_MODULE_ID = "\0" + MODULE_ID;
const CLIENT_ALIAS = "dotenv-gad/client";

export interface DotenvGadOptions {
  /**
   * Path (relative to project root) to the file that exports a
   * `defineSchema(...)` default export.
   *
   * Supports .ts, .js, .mjs, .cjs, and .json.
   *
   * @default './env.schema'
   */
  schemaPath?: string;

  /**
   * Prefix used to identify client-safe environment variables.
   * Any key starting with this prefix is automatically forwarded to the
   * browser bundle (unless marked `sensitive`).
   *
   * @default 'VITE_'
   */
  clientPrefix?: string;

  /**
   * Extra environment-variable keys (without the client prefix) that
   * should be forwarded to the browser bundle.  Everything else is
   * stripped at build time.
   *
   * @default []
   */
  publicKeys?: string[];

  /**
   * Absolute or relative glob(s) for additional .env files the plugin
   * should watch.  The plugin already watches `.env` and `.env.<mode>`
   * in the project root automatically.
   *
   * @default []
   */
  envFiles?: string[];

  /**
   * When `true` the plugin will write a `dotenv-gad.d.ts` file in the
   * project root after every successful validation, giving you full
   * IntelliSense on `import { env } from 'dotenv-gad/client'`.
   *
   * @default true
   */
  generatedTypes?: boolean;

  /**
   * Path (relative to project root) where the generated `.d.ts` file
   * will be written.
   *
   * @default './dotenv-gad.d.ts'
   */
  typesOutput?: string;
}

function resolveSchemaPath(root: string, schemaPath: string): string {
  const abs = resolve(root, schemaPath);

  if (existsSync(abs)) return abs;

  const suffixes = [".ts", ".js", ".mjs", ".cjs", ".json"];
  for (const suffix of suffixes) {
    const candidate = abs + suffix;
    if (existsSync(candidate)) return candidate;
  }

  throw new Error(
    `[dotenv-gad/vite] Could not find schema file starting from "${abs}".\n` +
      `Make sure your schema file exists and the path is correct.`
  );
}

/**
 * Generates a DTS declaration file for the validated environment variables.
 *
 * The file has NO top-level imports, keeping it a script file so that
 * `declare module` blocks are ambient declarations — they merge when the
 * real module is resolvable AND work as the sole definition when it isn't
 * (e.g. `moduleResolution: "node"` which can't resolve subpath exports).
 *
 * `import()` type expressions are used inline to reference `InferEnv`
 * and the user's schema without needing top-level imports.
 */
function generateDtsContent(
  filteredKeys: string[],
  schemaAbsPath: string,
  dtsAbsPath: string
): string {
  // Convert to a relative import path from the DTS output location
  let importPath = relative(dirname(dtsAbsPath), schemaAbsPath)
    .replace(/\\/g, "/")
    .replace(/\.(ts|js|mjs|cjs|json)$/, "");

  if (!importPath.startsWith(".")) {
    importPath = "./" + importPath;
  }

  const pickedKeys = filteredKeys.map((key) => `'${key}'`).join(" | ");

  // Inline import() type — keeps file as a script (no top-level imports)
  const envType =
    `Pick<import("dotenv-gad").InferEnv<typeof import("${importPath}").default>, ${pickedKeys}>`;

  return [
    "// ──────────────────────────────────────────────────────────────",
    "// This file is auto-generated by dotenv-gad.",
    "// Do NOT edit manually — it will be overwritten on next build/dev.",
    "// ──────────────────────────────────────────────────────────────",
    "",
    'declare module "dotenv-gad/client" {',
    `  interface DotenvGadEnv extends ${envType} {}`,
    "  export const env: DotenvGadEnv;",
    "  export default env;",
    "}",
    "",
    'declare module "virtual:dotenv-gad" {',
    '  import { DotenvGadEnv } from "dotenv-gad/client";',
    "  export const env: DotenvGadEnv;",
    "  export default env;",
    "}",
    "",
  ].join("\n");
}

/**
 * Filters validated environment variables for the browser bundle.
 * Only keys matching `clientPrefix` and explicitly whitelisted `publicKeys`
 * are included.  Keys marked `sensitive` in the schema are always excluded.
 */
function filterForBrowser(
  validatedEnv: Record<string, unknown>,
  clientPrefix: string,
  publicKeys: string[],
  schema: SchemaDefinition
): Record<string, unknown> {
  const allowed = new Set(publicKeys);
  const out: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(validatedEnv)) {
    if (schema[key]?.sensitive) continue;
    if (key.startsWith(clientPrefix) || allowed.has(key)) {
      out[key] = value;
    }
  }

  return out;
}

/**
 * Collects all .env files that should trigger re-validation on change.
 * Mirrors Vite's own env file precedence:
 *   .env  <  .env.local  <  .env.[mode]  <  .env.[mode].local
 */
function collectWatchedFiles(
  root: string,
  schemaPath: string,
  mode: string,
  extraEnvFiles: string[]
): string[] {
  const files: string[] = [schemaPath];

  const candidates = [
    ".env",
    ".env.local",
    `.env.${mode}`,
    `.env.${mode}.local`,
  ];

  for (const name of candidates) {
    const abs = resolve(root, name);
    if (existsSync(abs)) files.push(abs);
  }

  for (const extra of extraEnvFiles) {
    const abs = resolve(root, extra);
    if (existsSync(abs)) files.push(abs);
  }

  return files;
}

/**
 * Vite plugin for dotenv-gad.
 *
 * Validates environment variables against a schema definition, then
 * exposes the filtered result to the browser via a virtual module.
 */
export default function dotenvGadPlugin(
  options: DotenvGadOptions = {}
): Plugin {
  const {
    schemaPath = "./env.schema.ts",
    clientPrefix = "VITE_",
    publicKeys = [],
    envFiles = [],
    generatedTypes = true,
    typesOutput = "./dotenv-gad.d.ts",
  } = options;

  let resolvedConfig!: ResolvedConfig;
  let schemaAbsPath!: string;
  let watchedFiles: string[] = [];
  let currentMode = "development";

  // Cached schema — only reloaded when the schema file itself changes
  let cachedSchema: SchemaDefinition | null = null;
  // Lazily resolved real paths for watched files (avoids realpathSync on every HMR)
  let resolvedWatchedFiles: Set<string> | null = null;
  // Real path of the schema file for HMR cache invalidation
  let schemaRealPath: string | null = null;

  let currentFilteredEnv: Record<string, unknown> = {};
  let validationRan = false;
  let validationFailed = false;
  let lastValidationError = "";

  async function getSchema(): Promise<SchemaDefinition> {
    if (!cachedSchema) {
      cachedSchema = await loadSchema(schemaAbsPath);
    }
    return cachedSchema;
  }

  /**
   * Core validation loop:
   *  Load the schema (cached unless schema file changed)
   *  Load env vars using Vite's own loadEnv (respects envDir, mode, precedence)
   *  Validate with EnvValidator
   *  Filter for browser safety
   *  Optionally write .d.ts
   */
  async function validateAndUpdate(logger: {
    info: (...a: any[]) => void;
    warn: (...a: any[]) => void;
  }) {
    const schema = await getSchema();

    // Use Vite's loadEnv to respect envDir, mode, and .env file precedence.
    // Passing '' as the prefix loads ALL env vars, not just VITE_* ones.
    const { loadEnv: viteLoadEnv } = await import("vite");
    const envDir = resolvedConfig.envDir || resolvedConfig.root;
    const env = viteLoadEnv(currentMode, envDir, "");

    const validator = new EnvValidator(schema);
    const fullEnv = validator.validate(env);

    currentFilteredEnv = filterForBrowser(
      fullEnv as Record<string, unknown>,
      clientPrefix,
      publicKeys,
      schema
    );
    validationRan = true;
    validationFailed = false;

    if (generatedTypes) {
      const dtsPath = resolve(resolvedConfig.root, typesOutput);
      const content = generateDtsContent(
        Object.keys(currentFilteredEnv),
        schemaAbsPath,
        dtsPath
      );
      await writeFile(dtsPath, content, "utf-8");
      logger.info(`[dotenv-gad]   Generated types -> ${dtsPath}`);
    }
  }

  return {
    name: "vite-dotenv-gad",
    enforce: "pre",

    config(config, { mode }) {
      const root = config.root ?? process.cwd();
      currentMode = mode;
      schemaAbsPath = resolveSchemaPath(root, schemaPath);
      watchedFiles = collectWatchedFiles(root, schemaAbsPath, mode, envFiles);

      return undefined;
    },

    configResolved(config) {
      resolvedConfig = config;
    },

    async configureServer(server: ViteDevServer) {
      try {
        await validateAndUpdate(server.config.logger);
        server.config.logger.info(
          "[dotenv-gad]    Environment validated successfully."
        );
      } catch (err: unknown) {
        validationFailed = true;
        lastValidationError = String(err);
        server.config.logger.error(
          `\n${"=".repeat(70)}\n` +
            `[dotenv-gad]     VALIDATION FAILED - Fix your .env to continue\n` +
            `${"=".repeat(70)}\n` +
            `${lastValidationError}\n` +
            `${"=".repeat(70)}\n`
        );
      }

      server.watcher.add(watchedFiles);
    },

    async buildStart() {
      if (resolvedConfig.command === "build") {
        try {
          await validateAndUpdate(
            this.environment?.logger ?? resolvedConfig.logger
          );
          resolvedConfig.logger.info(
            "[dotenv-gad]   Environment validated successfully."
          );
        } catch (err: unknown) {
          this.error(
            `[dotenv-gad]    Validation failed — aborting build.\n\n${String(err)}`
          );
        }
      }
    },

    resolveId(id: string, _source, options) {
      if (id === MODULE_ID || id === CLIENT_ALIAS) {
        // Don't intercept in SSR — server code needs the full env, not
        // the browser-filtered subset. Let it fall through to the real
        // client.ts stub or the user's own server-side env setup.
        if ((options as { ssr?: boolean })?.ssr) return undefined;
        return RESOLVED_MODULE_ID;
      }
      return undefined;
    },

    async load(id: string) {
      if (id !== RESOLVED_MODULE_ID) return undefined;

      // Only re-validate if no prior hook has populated the env yet
      if (!validationRan) {
        try {
          await validateAndUpdate(resolvedConfig.logger);
        } catch (err: unknown) {
          validationFailed = true;
          lastValidationError = String(err);
        }
      }

      // If validation failed, return a module that throws at import time
      // so the developer gets a clear error in the browser console rather
      // than silently undefined values from an empty object.
      if (validationFailed) {
        const escaped = lastValidationError
          .replace(/\\/g, "\\\\")
          .replace(/`/g, "\\`")
          .replace(/\$/g, "\\$");
        return [
          `// dotenv-gad: validation failed — throwing so the error is visible`,
          `throw new Error(\`[dotenv-gad] Environment validation failed.\\n\\n${escaped}\\n\\nFix your .env file, then save to trigger re-validation.\`);`,
        ].join("\n");
      }

      const json = JSON.stringify(currentFilteredEnv, null, 2);

      return [
        `// Auto-generated by dotenv-gad`,
        `// Only ${clientPrefix}* keys (and explicitly whitelisted publicKeys) are included.`,
        `export const env = ${json};`,
        `export default env;`,
      ].join("\n");
    },

    async handleHotUpdate(context: HmrContext) {
      const { file, server } = context;

      // Lazily resolve and cache watched file real paths once
      if (!resolvedWatchedFiles) {
        resolvedWatchedFiles = new Set<string>();
        for (const w of watchedFiles) {
          try {
            resolvedWatchedFiles.add(realpathSync(w));
          } catch {
            resolvedWatchedFiles.add(w);
          }
        }
      }

      // Resolve schema real path once for cache-invalidation checks
      if (!schemaRealPath) {
        try {
          schemaRealPath = realpathSync(schemaAbsPath);
        } catch {
          schemaRealPath = schemaAbsPath;
        }
      }

      let normalised: string;
      try {
        normalised = realpathSync(file);
      } catch {
        normalised = file;
      }

      if (!resolvedWatchedFiles.has(normalised)) return;

      // If the schema file itself changed, invalidate the cached schema
      if (normalised === schemaRealPath) {
        cachedSchema = null;
      }

      server.config.logger.info(
        `[dotenv-gad]     detected change in ${file} — re-validating...`
      );

      try {
        await validateAndUpdate(server.config.logger);
        server.config.logger.info(
          "[dotenv-gad]     Re-validation passed."
        );
      } catch (err: unknown) {
        validationFailed = true;
        lastValidationError = String(err);
        server.config.logger.error(
          `\n[dotenv-gad]  Re-validation failed:\n${lastValidationError}\n`
        );
      }

      // Invalidate the virtual module so importing components get the update via HMR
      const virtualModule =
        server.moduleGraph.getModuleById(RESOLVED_MODULE_ID);
      if (virtualModule) {
        server.moduleGraph.invalidateModule(virtualModule);
        return [virtualModule];
      }

      return [];
    },
  };
}
