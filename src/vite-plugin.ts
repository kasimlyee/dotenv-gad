/**
 * Vite-dotenv-gad
 * 
 * Runs dotenv-gad validation exclusively in Node.js (inside Vite hooks),
 * then exposes the filtered, validated env through a virtual module.
 * 
 * Usage:
 *      import dotenvGad from 'dotenv-gad/vite';
 * 
 *      export default defineConfig({
 *          dotenvGad({
 *              schemaPath: './env.schema.ts', // path to your defineSchema file (default: './env.schema')
 *              publicKeys: ['MY_PUBLIC_KEY] // non-VITE_ keys to whitelist for the browser
 *          })
 *      }) 
 * 
 * Inside app:
 *      import { env } from 'dotenv-gad/client';
 *      console.log(env.VITE_API_URL);
 * 
 */




import { resolve } from "node:path";
import { existsSync, writeFileSync, realpathSync } from "node:fs";
import type {Plugin, ViteDevServer, HmrContext, ResolvedConfig } from "vite"
import type { SchemaDefinition } from "./schema.js";
import { loadEnv } from "./utils.js";
import { loadSchema } from "./cli/commands/utils.js";

const MODULE_ID = 'virtual:dotenv-gad';
const RESOLVED_MODULE_ID = '\0' + MODULE_ID;
const CLIENT_ALIAS = 'dotenv-gad/client';

export interface DotenvGadOptions{

     /**
   * Path (relative to project root) to the file that exports a
   * `defineSchema(...)` default export.
   *
   * Supports .ts, .js, .mjs, .cjs, and .json. 
   *
   * @default './env.schema'
   */
    schemaPath?: string;

    /**
   * Extra environment-variable keys (without the VITE_ prefix) that
   * should be forwarded to the browser bundle.  Everything else is
   * stripped at build time.
   *
   * @default []
   */
    publicKeys?: string[];

    /**
   * Absolute or relative glob(s) for additional .env files the plugin
   * should watch.  The plugin already watches `.env` and `.env.<mode>`
   * in the project root automatically.
   *
   * @default []
   */
    envFiles?: string[];

    /**
   * When `true` the plugin will write a `dotenv-gad.d.ts` file in the
   * project root after every successful validation, giving you full
   * IntelliSense on `import { env } from 'dotenv-gad/client'`.
   *
   * @default true
   */
    generatedTypes?: boolean;

    /**
   * Path (relative to project root) where the generated `.d.ts` file
   * will be written.
   *
   * @default './dotenv-gad.d.ts'
   */
    typesOutput?: string;
}



function resolveSchmaPath(root: string, schemaPath: string): string {
    const abs = resolve(root, schemaPath);

    if(existsSync(abs)) return abs;

    const suffixes = ['.ts', '.js', '.mjs', '.cjs','.json'];
    for(const suffix of suffixes){
        const candidate = abs  + suffix;
        if(existsSync(candidate)) return candidate;
    }

    throw new Error(`[dotenv-gad/vite]  Could not find schema file starting from "${abs}".\n
        Make sure your schema file exists and the path is correct.`)
}


/**
 * Generates a DTS declaration file for the validated environment
 * variables.
 *
 * The file contains two module declarations: one for the virtual
 * module and one for the client module. The virtual module
 * declaration is used to expose the validated environment
 * variables to the browser, while the client module declaration is
 * used to expose the same variables to the Node.js environment.
 *
 * The type of the environment variables is inferred from the schema
 * definition.
 *
 * @param filteredKeys - An array of environment variable names
 * that are safe for the browser (VITE_* + publicKeys whitelist)
 * @param schemaPath - The path to the schema definition file
 * @returns A string containing the DTS content to be written to
 * a file.
 */
function generateDtsContent(filteredKeys: string[], schemaPath: string): string {
    
    const importPath = schemaPath.replace(/\\/g,'/').replace(/\.(ts|js|json)$/,'');

    const pickedKeys = filteredKeys.map((key) => `'${key}'`).join(' | ');


   return [
    '// ──────────────────────────────────────────────────────────────',
    '// This file is auto-generated by dotenv-gad.',
    '// Do NOT edit manually — it will be overwritten on next build/dev.',
    '// ──────────────────────────────────────────────────────────────',
    '',
    `import type { InferEnv } from 'dotenv-gad';`,
    `import 'dotenv-gad/client'`,
    `import schema from '${importPath}';`,
    '',
    'declare module "dotenv-gad/client" {',
    '  // Extract the full typed env from the schema, then Pick only the',
    '  // keys that are safe for the browser (VITE_* + publicKeys whitelist)',
    `  export type DotenvGadEnv = Pick<InferEnv<typeof schema>, ${pickedKeys}>;`,
    '}',
    '',
    '',
    'declare module "virtual:dotenv-gad" {',
    `  import { DotenvGadEnv } from 'dotenv-gad/client';`,
    '  export const env: DotenvGadEnv;',
    '  export default env;',
    '}',
    '',
    '',
  ].join('\n');
}

/**
 * Filters the given validated environment variables for the browser.
 * Only variables that start with `VITE_` or are listed in `publicKeys` are included,
 * and variables marked `sensitive` in the schema are always excluded.
 * @param validatedEnv - The validated environment variables.
 * @param publicKeys - An array of environment variable names to whitelist for the browser.
 * @param schema - The schema definition used to check the `sensitive` flag.
 * @returns A new object containing only the safe, whitelisted environment variables.
 */
function filterForBrowser(validatedEnv: Record<string, unknown>, publicKeys: string[], schema: SchemaDefinition): Record<string, unknown>{
    const allowed = new Set(publicKeys);
    const out: Record<string, unknown> = {};

    for(const [key, value] of Object.entries(validatedEnv)){
        if(schema[key]?.sensitive) continue;
        if(key.startsWith('VITE_') || allowed.has(key)){
            out[key] = value;
        }
    }

    return out
}

interface ValidationResult{
    fullEnv: Record<string, unknown>;
    schema: SchemaDefinition;
}

async function runValidation(schemaPath: string): Promise<ValidationResult>{
    const schema = await loadSchema(schemaPath);
    const fullEnv = loadEnv(schema);

    return {
        fullEnv: fullEnv,
        schema: schema
    }
}

function collectWatchedFiles(root: string, schemaPath: string, mode: string, extraEnvFiles: string[]): string[]{
    const files: string[] = [schemaPath]

    const dotenv = resolve(root, '.env');
    if(existsSync(dotenv)) files.push(dotenv);

    const dotenvMode = resolve(root, `.env.${mode}`);
    if(existsSync(dotenvMode)) files.push(dotenvMode);

    const dotenvLocal = resolve(root, '.env.local');
    if(existsSync(dotenvLocal)) files.push(dotenvLocal);

    for(const extra of extraEnvFiles){
        const abs = resolve(root, extra);
        if(existsSync(abs)) files.push(abs);
    }

    return files
}

    /**
     * Vite plugin for dotenv-gad.
     * 
     * Validate your environment variables against a schema definition.
     * 
     * Options:
     * - `schemaPath`: The path to your schema definition file.
     * - `publicKeys`: An array of environment variable names to whitelist for the browser.
     * - `envFiles`: An array of environment variable file names to include in the validation.
     * - `generatedTypes`: A boolean indicating whether or not to generate a DTS declaration file for the validated environment variables.
     * - `typesOutput`: The path to which to write the generated DTS declaration file.
     * 
     * @param options - An object containing the above options.
     * @returns A vite plugin object.
     */
export default function dotenvGadPlugin(options: DotenvGadOptions = {}): Plugin{

    const {
        schemaPath = './env.schema.ts',
        publicKeys = [],
        envFiles = [],
        generatedTypes = true,
        typesOutput = './dotenv-gad.d.ts'
    } = options;

    let resolvedConfig!: ResolvedConfig;
    let schemaAbsPath!: string;
    let watchedFiles: string[]= [];

    let currentFilteredEnv: Record<string, unknown> = {}
    let currentSchema: Record<string, unknown> = {}

/**
 * Validates the environment variables against the schema definition
 * and updates the current filtered environment variables and schema.
 * If `generatedTypes` is true, generates a DTS declaration file
 * for the validated environment variables.
 * @param logger - An object containing `info` and `warn` methods
 * to log information and warnings, respectively.
 */
    async function validateAndUpdate(logger: {info: (...a: any[]) =>void; warn:(...a: any[]) =>void}){
        const result = await runValidation(schemaAbsPath);

        currentFilteredEnv = filterForBrowser(result.fullEnv, publicKeys, result.schema);
        currentSchema = result.schema;

        if(generatedTypes){
            const dtsPath = resolve(resolvedConfig.root, typesOutput);
            const content = generateDtsContent(Object.keys(currentFilteredEnv), schemaAbsPath);
            writeFileSync(dtsPath, content, 'utf-8');
            logger.info(`[dotenv-gad]   ✓ Generated types → ${dtsPath}`);
        }

    }

    return {
        name: 'vite-dotenv-gad',
        enforce: 'pre',

        config(config, {mode}){
            const root = config.root ?? process.cwd();
            schemaAbsPath = resolveSchmaPath(root, schemaPath);
            watchedFiles = collectWatchedFiles(root, schemaAbsPath, mode, envFiles);

            return undefined;
        },

        configResolved(config){
            resolvedConfig = config;
        },

        async configureServer(server: ViteDevServer){
            try{
                await validateAndUpdate(server.config.logger);
                 server.config.logger.info('[dotenv-gad]    ✓ Environment validated successfully.');
            }catch(err: unknown){
                 server.config.logger.error(
          `\n${'='.repeat(70)}\n` +
          `[dotenv-gad]     ✗ VALIDATION FAILED - Fix your .env to continue\n` +
          `${'='.repeat(70)}\n` +
          `${String(err)}\n` +
          `${'='.repeat(70)}\n`
        );

            }

            server.watcher.add(watchedFiles);
        },

        async buildStart(){
            if(resolvedConfig.command === 'build'){
                try{
                    await validateAndUpdate(this.environment?.logger ?? resolvedConfig.logger);
                     resolvedConfig.logger.info('[dotenv-gad]   ✓ Environment validated successfully.');
                }catch(err:unknown){
                    this.error(`[dotenv-gad]    ✗ Validation failed — aborting build.\n\n${String(err)}`);
                }
            }
        },

        resolveId(id: string){
            if(id === MODULE_ID || id === CLIENT_ALIAS){
                return RESOLVED_MODULE_ID;
            }
            return undefined;
        },

        async load(id: string){
            if(id !== RESOLVED_MODULE_ID) return undefined;

            if(Object.keys(currentFilteredEnv).length === 0){
                await validateAndUpdate(resolvedConfig.logger); //it it fails we thro so the build stops
            }

            const json = JSON.stringify(currentFilteredEnv, null, 2);

            return [
        `// Auto-generated by dotenv-gad`,
        `// Only VITE_* keys (and explicitly whitelisted publicKeys) are included.`,
        `export const env = ${json};`,
        `export default env;`,
      ].join('\n');
        },

        async handleHotUpdate(context: HmrContext){
            const {file, server} = context;

            let normalised: string;

            try{
                normalised = realpathSync(file);
            }catch{
                normalised =  file;
            }

            const isWatched = watchedFiles.some((w) =>{
                try{
                    return realpathSync(w) ===normalised;
                }catch{
                    return w === normalised
                }
            });
            if (!isWatched) return; //vite will handle the update normally.

            server.config.logger.info(`[dotenv-gad]     detected change in ${file} — re-validating…`);

            try{
                await validateAndUpdate(server.config.logger);
               server.config.logger.info('[dotenv-gad]     ✓ Re-validation passed.');
            }catch(err:unknown){
                //In Dev Mode: Just log the failure but not to kill the server.
                server.config.logger.error(`\n[dotenv-gad]  ✗ Re-validation failed:\n${String(err)}\n`);
            }

            // So we invalidate the virtual module in Vite's module graph such that
            // any component importing it receives an updated payload via HMR.
            const virutalModule = server.moduleGraph.getModuleById(RESOLVED_MODULE_ID);
            if(virutalModule){
                server.moduleGraph.invalidateModule(virutalModule);

                return [virutalModule]
            }

            return [];
        }
    }
}