{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"dotenv-gad \u2014 Documentation","text":"<p>Welcome to the official documentation for dotenv-gad \u2014 a tiny, TypeScript-friendly environment validation library for Node.js.</p> <p>Use the navigation on the left to explore guides, examples, the CLI, and the schema reference.</p> <p>Quick links:</p> <ul> <li>Guide: Usage and patterns</li> <li>Grouping: Grouped env variables with <code>envPrefix</code></li> <li>CLI: <code>dotenv-guard</code> commands and types</li> <li>Schema reference: Schema rule reference and examples</li> </ul> <p>If you find missing info or want to contribute docs, open a PR in this repository.</p>"},{"location":"_sidebar/","title":"sidebar","text":"<ul> <li>Home</li> <li>Getting Started</li> <li>Quick Start</li> <li>CLI</li> <li>Examples</li> <li>Express</li> <li>Next.js</li> <li>Create Env Proxy</li> <li>Advanced validation patterns</li> <li>Features</li> <li>Grouping (envPrefix)</li> <li>Validation &amp; Types</li> <li>Error Reporting &amp; Secrets</li> <li>Advanced</li> <li>Benchmarks</li> <li>Migration / Upgrading</li> </ul>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>A lightweight benchmark is included at <code>benchmarks/validate-bench.js</code> to measure validation throughput. The benchmark appends results to <code>benchmarks/results.txt</code> so CI can collect them as artifacts.</p> <p>Run locally:</p> <pre><code>npm run build\nnpm run bench\n</code></pre> <p>Example output:</p> <pre><code>2026-01-12T00:00:00.000Z | runs=200000 | totalMs=999.909 | msPerRun=0.004999\n</code></pre> <p>We use a nightly GitHub Action to collect benchmark results and upload them as an artifact. Over time we'll add regression checks to warn or fail the build when performance decreases beyond a threshold.</p>"},{"location":"cli/","title":"CLI Usage","text":"<p>The CLI exposes convenient commands for working with your schema and environment files.</p> <p>Commands</p> <ul> <li><code>npx dotenv-gad check --strict</code> \u2014 Validate <code>.env</code> against the schema. Use <code>--strict</code> to fail on extra variables.</li> <li><code>npx dotenv-gad sync</code> \u2014 Generate or update <code>.env.example</code> from your schema (sensitive values are excluded).</li> <li><code>npx dotenv-gad types</code> \u2014 Generate <code>env.d.ts</code> TypeScript types for your schema.</li> <li><code>npx dotenv-gad init</code> \u2014 Create a starter schema.</li> <li><code>npx dotenv-gad fix</code> \u2014 Attempt interactive fixes for common issues.</li> </ul> <p>Examples</p> <p>Validate a repo with CI-friendly output (use exit codes):</p> <pre><code>npx dotenv-gad check --strict\n</code></pre> <p>Add a CI step in GitHub Actions to prevent merging invalid env changes:</p> <pre><code>- name: Validate .env\n  run: npx dotenv-gad check --strict\n</code></pre> <p>Scaffold <code>.env.example</code> grouped sections (uses <code>envPrefix</code> when present):</p> <pre><code>npx dotenv-gad sync --output .env.example\n</code></pre>"},{"location":"examples/advanced/","title":"Advanced validation patterns","text":"<p>Custom validators and transforms let you encode domain-specific checks succinctly.</p> <p>Custom validator example:</p> <pre><code>const schema = defineSchema({\n  PASSWORD: {\n    type: 'string',\n    required: true,\n    validate: (v) =&gt; v.length &gt;= 8 &amp;&amp; /[A-Z]/.test(v),\n    error: 'Password must be 8+ chars and include an uppercase letter'\n  }\n});\n</code></pre> <p>Transform example (comma-separated flags):</p> <pre><code>const schema = defineSchema({\n  FEATURES: {\n    type: 'array',\n    transform: (v) =&gt; String(v).split(',').map((s) =&gt; s.trim()),\n  }\n});\n</code></pre> <p>Combining grouping and custom validators:</p> <pre><code>const schema = defineSchema({\n  DATABASE: {\n    type: 'object',\n    properties: {\n      HOST: { type: 'string', required: true },\n      PORT: { type: 'port', default: 5432 },\n      PWD: { type: 'string', sensitive: true },\n    }\n  }\n});\n\n// Prefixed envs like DATABASE_HOST and DATABASE_PWD will be validated\n</code></pre> <p>Tips - Prefer small, focused custom validators that return boolean and use the <code>error</code> message for clarity. - Use <code>transform</code> to normalize common inputs (trim, split CSVs, parse numbers with defaults) before validation rules run.</p>"},{"location":"examples/express/","title":"Express Example","text":"<p>This example shows how to use <code>dotenv-gad</code> in an Express application to validate environment variables and fail fast if required configuration is missing.</p> <p>Schema (<code>env.schema.ts</code>):</p> <pre><code>import { defineSchema } from 'dotenv-gad';\n\nexport default defineSchema({\n  PORT: { type: 'number', default: 3000, docs: 'Port to run the server on' },\n  DATABASE_URL: { type: 'string', required: true, sensitive: true },\n});\n</code></pre> <p>Server (<code>server.ts</code>):</p> <pre><code>import express from 'express';\nimport schema from './env.schema';\nimport { loadEnv } from 'dotenv-gad';\n\nconst env = loadEnv(schema); // throws on validation errors\n\nconst app = express();\napp.get('/', (req, res) =&gt; res.send('Hello'));\n\napp.listen(env.PORT, () =&gt; console.log(`Server running on ${env.PORT}`));\n</code></pre> <p>Notes - Use <code>includeRaw</code> during local debugging if you want raw values to appear in errors: <code>loadEnv(schema, { includeRaw: true })</code>. - For production, keep <code>includeRaw</code> disabled to avoid leaking values in logs.</p> <p>Try it online</p> <ul> <li>StackBlitz: https://stackblitz.com/github/kasimlyee/dotenv-gad/tree/opt/quick-refractor/examples/express</li> <li>Run locally:</li> </ul> <pre><code>cd examples/express\nnpm ci\nnpm start\n</code></pre>"},{"location":"examples/nextjs/","title":"Next.js Example","text":"<p>When using <code>dotenv-gad</code> with Next.js, you can validate environment variables at build time and inject typed values into <code>next.config.js</code> or use them in server-side code.</p> <p><code>next.config.js</code>:</p> <pre><code>const { loadEnv } = require('dotenv-gad');\nconst schema = require('./env.schema');\n\nconst env = loadEnv(schema);\n\nmodule.exports = {\n  env: {\n    API_URL: env.API_URL,\n  }\n};\n</code></pre> <p>Notes - Validating env at build time helps catch missing or invalid configuration before deployment. - If you prefer to keep secret values server-only, validate them in server-side code rather than injecting into client bundles.</p> <p>Try it online</p> <ul> <li>StackBlitz: https://stackblitz.com/github/kasimlyee/dotenv-gad/tree/opt/quick-refractor/examples/nextjs</li> <li>Run locally:</li> </ul> <pre><code>cd examples/nextjs\nnpm ci\nnpm run dev\n</code></pre>"},{"location":"examples/proxy/","title":"CreateEnvProxy &amp; Lazy Parsing","text":"<p><code>createEnvProxy</code> returns a proxy that throws if you access unvalidated properties. This is useful to ensure parts of your app only use validated values.</p> <p>Example:</p> <pre><code>import { loadEnv, createEnvProxy } from 'dotenv-gad';\nimport schema from './env.schema';\n\nconst env = loadEnv(schema);\nconst safeEnv = createEnvProxy(env);\n\n// Later in the code:\nfunction connect() {\n  const url = safeEnv.DATABASE_URL; // throws if DATABASE_URL not validated\n}\n</code></pre> <p>Lazy parsing: If you want values to be parsed only when accessed, consider using a transform that returns a getter or using <code>createEnvProxy</code> to centralize access.</p>"},{"location":"guide/errors/","title":"Error Reporting &amp; Secrets","text":"<p>dotenv-gad reports structured validation errors using an <code>AggregateError</code>. Example output:</p> <pre><code>Environment validation failed:\n  - DATABASE_URL: Missing required environment variable\n  - PORT: Must be a number (received: \"abc\")\n  - API_KEY: Must start with 'sk_' (received: \"invalid\")\n</code></pre> <p>Redaction and options</p> <ul> <li>By default, sensitive properties are masked (<code>****</code>) in error output.</li> <li>Non-sensitive values are truncated when long to avoid leaking secrets.</li> <li>Set <code>includeRaw: true</code> on <code>loadEnv</code> or <code>EnvValidator</code> to include raw non-sensitive values in the error report.</li> <li>Set <code>includeSensitive: true</code> (with <code>includeRaw</code>) to show sensitive values too \u2014 only use for local debugging.</li> </ul> <p>Programmatic access</p> <p><code>AggregateError.errors</code> contains structured objects:</p> <pre><code>[ { key: 'PORT', message: 'Must be a number', value: 'abc', rule: {...} } ]\n</code></pre> <p>Use the <code>toString()</code> method to render a friendly message for CLI output.</p>"},{"location":"guide/grouping/","title":"Grouping / Namespaced envs","text":"<p>You can group related environment variables into a single object by defining <code>properties</code> on an <code>object</code>-typed rule. Optionally provide <code>envPrefix</code> to control variable naming; by default <code>envPrefix</code> is <code>&lt;KEY&gt;_</code> (e.g., <code>DATABASE_</code>).</p> <p>Example schema:</p> <pre><code>const schema = defineSchema({\n  DATABASE: {\n    type: 'object',\n    envPrefix: 'DATABASE_', // optional\n    properties: {\n      DB_NAME: { type: 'string', required: true },\n      PORT: { type: 'port', default: 5432 },\n      PWD: { type: 'string', sensitive: true }\n    }\n  }\n});\n</code></pre> <p>Given env variables:</p> <pre><code>DATABASE_DB_NAME=mydb\nDATABASE_PORT=5432\nDATABASE_PWD=supersecret\n</code></pre> <p><code>loadEnv(schema)</code> returns:</p> <pre><code>{ DATABASE: { DB_NAME: 'mydb', PORT: 5432, PWD: 'supersecret' } }\n</code></pre> <p>Behavior &amp; Notes</p> <ul> <li>Prefixed variables take precedence over a top-level JSON <code>DATABASE</code> env if both are present; in that case a warning is printed.</li> <li>In strict mode, unexpected grouped subkeys (e.g., <code>DATABASE_EXTRA</code>) cause validation to fail.</li> <li><code>sensitive</code> and <code>includeRaw</code> apply per property inside groups.</li> <li>The <code>sync</code> CLI emits grouped <code>.env.example</code> entries automatically.</li> </ul> <p>This approach keeps structured configuration tidy and works well with 12-factor apps and containerized deployment environments.</p>"},{"location":"guide/migration/","title":"Migration / Upgrading","text":"<p>This release added:</p> <ul> <li>Grouping via <code>envPrefix</code> for <code>object</code> types</li> <li><code>includeRaw</code> / <code>includeSensitive</code> options for error reporting</li> <li>Benchmarks and CI collection</li> </ul> <p>If you relied on reading a top-level JSON <code>DATABASE</code> value, note that prefixed vars take precedence when both are present; consider removing or updating the top-level JSON env to avoid ambiguity.</p>"},{"location":"guide/usage/","title":"Quick Start","text":"<p>Install:</p> <pre><code>npm install dotenv-gad\n</code></pre> <p>Define a schema (<code>env.schema.ts</code>):</p> <pre><code>import { defineSchema } from 'dotenv-gad';\n\nexport default defineSchema({\n  PORT: { type: 'number', default: 3000, docs: 'Port to run the server on' },\n  DATABASE_URL: { type: 'string', required: true, sensitive: true },\n});\n</code></pre> <p>Load environment:</p> <pre><code>import { loadEnv } from 'dotenv-gad';\nimport schema from './env.schema';\n\nconst env = loadEnv(schema);\nconsole.log(env.PORT);\n</code></pre> <p>Options</p> <ul> <li><code>strict</code> \u2014 when true, fail on environment variables not present in the schema.</li> <li><code>includeRaw</code> \u2014 include raw values in error reports (non-sensitive by default).</li> <li><code>includeSensitive</code> \u2014 when used with <code>includeRaw</code> will reveal values marked sensitive (use only for local debugging).</li> </ul> <p>CLI</p> <ul> <li><code>npx dotenv-gad check</code> \u2014 check .env against the schema</li> <li><code>npx dotenv-gad sync</code> \u2014 generate/update <code>.env.example</code></li> <li><code>npx dotenv-gad types</code> \u2014 generate <code>env.d.ts</code></li> </ul>"},{"location":"reference/schema/","title":"Schema Reference","text":"<p>The schema is a <code>Record&lt;string, SchemaRule&gt;</code> where <code>SchemaRule</code> includes the following fields:</p> <ul> <li><code>type</code> \u2014 one of <code>string</code>, <code>number</code>, <code>boolean</code>, <code>date</code>, <code>object</code>, <code>array</code>, <code>email</code>, <code>url</code>, <code>ip</code>, <code>json</code>, <code>port</code></li> <li><code>required</code> \u2014 boolean</li> <li><code>default</code> \u2014 any</li> <li><code>min</code>, <code>max</code>, <code>minLength</code>, <code>maxLength</code></li> <li><code>validate</code> \u2014 <code>(value) =&gt; boolean</code> custom validator</li> <li><code>transform</code> \u2014 <code>(value) =&gt; any</code> value transform</li> <li><code>sensitive</code> \u2014 boolean; when true this value is masked in errors and excluded from <code>.env.example</code></li> <li><code>docs</code> \u2014 string documentation</li> <li><code>enum</code> \u2014 array of allowed values</li> <li><code>regex</code> / <code>regexError</code></li> <li><code>items</code> \u2014 <code>SchemaRule</code> for array items</li> <li><code>properties</code> \u2014 <code>Record&lt;string, SchemaRule&gt;</code> for <code>object</code> types</li> <li><code>envPrefix</code> \u2014 optional string used to map grouped envs into <code>object</code> properties (defaults to <code>&lt;KEY&gt;_</code> when <code>properties</code> exists)</li> </ul> <p>Example:</p> <pre><code>{\n  DATABASE: {\n    type: 'object',\n    properties: {\n      HOST: { type: 'string' },\n      PORT: { type: 'port', default: 5432 }\n    }\n  }\n}\n</code></pre>"}]}